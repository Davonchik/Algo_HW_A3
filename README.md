# Исследование алгоритмов QUICK SORT и INTROSORT

## Описание задачи

В рамках работы выполнено экспериментальное исследование двух алгоритмов сортировки:
1. **QUICK SORT** — стандартная рекурсивная реализация с использованием случайного выбора опорного элемента.
2. **INTROSORT (QUICK+HEAP+INSERTION SORT)** — гибридная реализация, переключающаяся между алгоритмами QUICK SORT, HEAP SORT и INSERTION SORT по следующим правилам:
   - Основной сортировкой является QUICK SORT.
   - Переключение на HEAP SORT, если глубина рекурсии достигает $2 * \log_{2}{N}$.
   - Переключение на INSERTION SORT, если в сортируемой части массива остается менее 16 элементов.

### Цель
Сравнить производительность алгоритмов на массивах различного размера и структуры, определить влияние переключений на производительность гибридного алгоритма, а также провести анализ времени работы с использованием библиотеки `std::chrono`.

---

## Подготовка тестовых данных

### Реализация класса `ArrayGenerator`
Для генерации массивов был написан класс `ArrayGenerator`, позволяющий создавать три типа массивов:
1. **Случайные значения** — элементы массива находятся в диапазоне `[0, 6000]`.
2. **Обратный порядок** — элементы массива отсортированы по убыванию.
3. **Почти отсортированные массивы** — некоторое количество случайных пар элементов переставлено местами.

**Параметры тестовых данных:**
- Размеры массивов: от 5000 до 100000 элементов с шагом 1000 (увеличил размеры исходных данных в 10 раз и замеры проводил в наносекундах в связи с быстрой работой моего компьютера, так как на меньших данных появлялись результаты с времененем выполнения 0, т.е. std::chrono не мог засечь настолько маленький промежуток времени).
- Массивы берутся разной длины от 5000 до 100000 с шагом 1000.
- Диапазон случайных значений взят от 0 до 6000.

---

## Эмпирический анализ стандартного алгоритма QUICK SORT

### Методика
Замеры времени работы выполнялись для стандартного алгоритма QUICK SORT с усреднением по 10 запускам для каждого размера массива. Использовалась библиотека `std::chrono`.

## Эмпирический анализ гибридного алгоритма INTROSORT

### Реализация гибридного алгоритма
Гибридная реализация INTROSORT реализована с учетом указанных правил переключений:
- Переход на HEAP SORT при превышении глубины рекурсии $2 * \log_{2}{N}$.
- Переход на INSERTION SORT для массивов длиной менее 16.

### Методика
Замеры аналогичны предыдущему этапу: усреднение времени выполнения по 10 запускам для каждого размера массива.

### Результаты
Графики времени выполнения QUICK SORT и INTROSORT для всех категорий массивов:

1. **Случайные массивы**  
   ![1](Random%20Array.png)

2. **Обратный порядок**  
   ![2](Reversed%20Array.png)

3. **Почти отсортированные массивы**  
   ![3](Near%20Sorted%20Array.png)

---

## Сравнительный анализ

### Итоги
**Производительность:** INTROSORT показывает лучшую производительность во всех рассматриваемых случаях.

### Выводы
1. INTROSORT - это одна из лучших существующих сортировок, которая устраняет недостатки QUICK SORT.
2. За счет использования HEAP SORT при достижении пороговой глубины рекурсии исключается возможность возникновения плохих случаев работы QUICK SORT (например, когда QUICK SORT работает за $\mathcal{O}(N^2)$
3. Также за счет использования INSERTION SORT на маленьких массивах улучшена константа времени исполнения (по аналогии с задачей про MERGE SORT).

---

## Приложения

### Файлы

#### С данными
- `q_s_test1.txt`
- `q_s_test2.txt`
- `q_s_test3.txt`
- `i_s_test1.txt`
- `i_s_test2.txt`
- `i_s_test3.txt`

#### Графики
- `Random Array.png`
- `Reversed Array.png`
- `Near Sorted Array.png`

#### Файлы с программами
- `main.cpp` (основная логика сортировок + генерация даных)
- `analysis.py` (построение графиков на данных)

### Также реализован был класс SortTester, включающий функции эмпирического замера времени работы рассматриваемых алгоритмов сортировки.

### Ссылка на CodeForces
ID посылки задачи A3i: **[292819921]**

### Ссылка на репозиторий
[GitHub репозиторий с исходными данными и реализациями](https://github.com/Davonchik/Algo_HW_A3)
